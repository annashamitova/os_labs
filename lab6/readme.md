# Краткое описание реализованных алгоритмов и структур данных

## **Пузырьковая сортировка (Bubble Sort)**  
Простой алгоритм сортировки, основанный на последовательном сравнении пары соседних элементов с последующей перестановкой, если они находятся в неправильном порядке.

**Алгоритм:**
1. Сравнить элементы `i` и `i+1`
2. Если `arr[i] > arr[i+1]`, обменять
3. Повторять, пока не произойдёт проход без обменов

### **Аналитическая оценка сложности (O(f(n))):**
- **Лучший случай:** `O(n)` — если массив уже отсортирован (с оптимизацией `break`)
- **Средний случай:** `O(n²)`
- **Худший случай:** `O(n²)`


# Используемые структуры данных

## **1. Array**
- Предоставляет `O(1)` доступ к элементам  
- Лучшая структура для пузырьковой сортировки  
- Используется массив `int[]`, заполненный `Random`

## **2. Stack**
- Основан на `Vector`, что приводит к:  
  - синхронизации  
  - дополнительным накладным расходам  
- Пузырёк применяется напрямую к стеку  

## **3. HashMap**
HashMap **нельзя сортировать напрямую**, поэтому применяется схема:

1. Скопировать значения в `ArrayList`
2. Отсортировать пузырьком
3. Записать обратно

Сортировка фактически выполняется на `ArrayList`.


# 1. Результаты эксперимента

| Размер | Array (ms) | Stack (ms) | HashMap→ArrayList (ms) |
|-------|-----------:|-----------:|-------------------------:|
| 100   | 0.285      | 4.491      | 2.522                   |
| 1000  | 5.050      | 64.286     | 26.381                  |
| 5000  | 42.316     | 1427.557   | 178.444                 |
| 10000 | 197.519    | 5688.777   | 755.983                 |


## Сравнение теоретической оценки и экспериментальных данных

### **Array**
- Рост времени близок к квадратичному
- Быстрее остальных благодаря прямому доступу к элементам по индексам и отсутствию вызовов методов при обращении к элементам

### **Stack**
- Самый медленный
- Это объясняется тем, что Stack основан на `Vector`, каждый вызов get()/set() проходит через синхронизированные методы, выполняются дополнительные проверки индекса

### **HashMap**
- Быстрее стека, но медленнее массива  
- Сортировка выполняется не по HashMap, а через массив (требуется предварительно скопировать элементы туда и обратно), доступ к массиву осуществляется через методы get/set(), что медленнее прямого доступа в массив


## Итог сравнения

| Структура | Скорость | Причина |
|----------|----------|---------|
| **Array** | Самая быстрая | прямой доступ, минимум накладных расходов |
| **HashMap → ArrayList** | Средняя | преобразование + сортировка |
| **Stack** | Самая медленная | синхронизированный Vector |


## Статистическая значимость экспериментов

Обеспечена благодаря:

- повторению каждого эксперимента (`runs = 3`)
- усреднению результатов
- одинаковым условиям выполнения
- использованию случайных данных
