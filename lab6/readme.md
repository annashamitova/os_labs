# Краткое описание реализованных алгоритмов и структур данных

## **Пузырьковая сортировка (Bubble Sort)**  
Простой алгоритм сортировки, основанный на последовательном сравнении пары соседних элементов с последующей перестановкой, если они находятся в неправильном порядке.

**Алгоритм:**
1. Сравнить элементы `i` и `i+1`
2. Если `arr[i] > arr[i+1]`, обменять
3. Повторять, пока не произойдёт проход без обменов

### **Аналитическая оценка сложности (O(f(n))):**
- **Лучший случай:** `O(n)` — если массив уже отсортирован (с оптимизацией `break`)
- **Средний случай:** `O(n²)`
- **Худший случай:** `O(n²)`


# Используемые структуры данных

## **1. Array**
- Предоставляет прямой доступ к элементам за `O(1)` 
- Лучшая структура для пузырьковой сортировки  
- Используется массив, заполненный случайными значениями

## **2. HashMap**
HashMap **нельзя сортировать напрямую** (т.к. это неупорядоченная коллекция пар "ключ-значение", а сортировка пузырбком требует упорядоченной последователности с возможностью доступа по индексу), поэтому применяется схема:

- Скопировать значения в массив
- Отсортировать пузырьком
- Записать обратно в HashMap по ключам `0..n-1`

Сортировка фактически выполняется на `ArrayList`.

## **3. Stack**
Stack **нельзя сортировать напрямую** (т.к. сортировка пузырьком требует произвольного доступа к элементам, а стек предоставляет доступ только к вершине), поэтому применяется схема с двумя стеками: 

- На каждом проходе максимальный элемент «всплывает» к вершине основного стека
- Для этого используется вспомогательный стек для временного хранения элементов
- Обмен соседних элементов эмулируется через извлечение (pop) и возврат (push) в нужном порядке

## **4. LinkedList**
- Сортировка реализована напрямую через `get(j)` и `set(j, value)`
- Однако каждая операция `get(j)` выполняется за `O(j)`, так как требует прохода от начала списка
- В результате общая сложность становится `O(n³)`, несмотря на формальную `O(n²)` структуру алгоритма

# 1. Результаты эксперимента

| Размер | Array (ms) | HashMap (ms) | Stack (ms) | LinkedList (ms) |
|:------:|:----------:|:-----------:|:-----------:|:---------------:|
| 10     | 0.003      | 0.005      | 0.044        | 0.027           |
| 100    | 0.064      | 0.087      | 0.541        | 0.853           |
| 1000   | 1.546      | 1.682      | 8.845        | 479.113         |


## Сравнение теоретической оценки и экспериментальных данных

### **Array**
- Рост времени близок к квадратичному
- Быстрее остальных благодаря прямому доступу к элементам по индексам и отсутствию вызовов методов при обращении к элементам

### **HashMap**
- Почти такая же скорость, как у массива
- Сортировка выполняется на массиве, время на перенос элементов туда-обратно не учитывается

### **Stack**
- Значительно медленнее массива
- Это объясняется тем, что необходимостью многократного перекладывания между двумя стеками на каждом проходе (требуется ~2n операций на каждый проход, что увеличивает константу, но асимптотика остается `O(n)`)

### **LinkedList**
- Самая медленная сортировка 
- Каждая операция `get(j)` требует прохода от начала списка до позиции `j`, что занимает в среднем `O(j)` времени, поскольку в пузырьковой сортировке выполняется `O(n²)` таких обращений, общая временная сложность на практике возрастает до `O(n³)`

## Итог сравнения

| Структура | Скорость | Причина |
|-----------|----------|---------|
| **Array** | самая быстрая | прямой доступ, минимум накладных расходов |
| **HashMap** | почти как массив | преобразование + сортировка |
| **Stack** | медленнее | необходимость перекладывания элементов между стеками на каждом подходе |
| **LinkedList** | самая медленная | O(n) доступ к элементу |


## Статистическая значимость экспериментов

Обеспечена благодаря:

- повторению каждого эксперимента (`runs = 100`)
- усреднению результатов
- одинаковым условиям выполнения
- использованию случайных данных
